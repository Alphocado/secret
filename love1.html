<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Heart Particle - Three.js</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #0b0b0b;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
      // =====================
      // SCENE SETUP
      // =====================
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.z = 50;

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // =====================
      // HEART PATH FUNCTION
      // =====================
      function createHeartPath(particleIndex, totalParticles) {
        const t = (particleIndex / totalParticles) * Math.PI * 2;
        const scale = 2.2;

        let x = 16 * Math.pow(Math.sin(t), 3);
        let y =
          13 * Math.cos(t) -
          5 * Math.cos(2 * t) -
          2 * Math.cos(3 * t) -
          Math.cos(4 * t);

        const finalX = x * scale;
        const finalY = y * scale;
        const z = Math.sin(t * 4) * 2;

        const jitterStrength = 0.2;

        return new THREE.Vector3(
          finalX + (Math.random() - 0.5) * jitterStrength,
          finalY + (Math.random() - 0.5) * jitterStrength,
          z + (Math.random() - 0.5) * jitterStrength,
        );
      }

      // =====================
      // PARTICLES
      // =====================
      const particleCount = 1200;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const pos = createHeartPath(i, particleCount);
        positions[i * 3] = pos.x;
        positions[i * 3 + 1] = pos.y;
        positions[i * 3 + 2] = pos.z;
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3),
      );

      const material = new THREE.PointsMaterial({
        color: 0xff3366,
        size: 0.4,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
      });

      const heartParticles = new THREE.Points(geometry, material);
      scene.add(heartParticles);

      // =====================
      // ANIMATION LOOP
      // =====================
      function animate() {
        requestAnimationFrame(animate);

        heartParticles.rotation.y += 0.002;
        heartParticles.rotation.x += 0.001;

        renderer.render(scene, camera);
      }

      animate();

      // =====================
      // RESPONSIVE
      // =====================
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
